using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using NWaves.Filters.Butterworth;
using NWaves.Signals;
using Oculus.Interaction;
using LowPassFilter = NWaves.Filters.Butterworth.LowPassFilter;

public class MyoSample : MonoBehaviour
{
    private MyoClassification _myoClassification;
    public OVRsEMGHandModifier _handModifierR;

    List<float[]> myoDataQueue = new(MyoClassification.SEQ_LEN);
    public static float[,,] emgTensor = new float[1, MyoClassification.SEQ_LEN, MyoClassification.INPUT_DIM];
    
    private bool inferenceActive = true;
    
    private OVRPlugin.Quatf[] _handRotationsR;

    List<float[]> csvEMGData = new();
    List<float[]> csvAngleData = new();
    private int csvDataCounter = 0;


    private LowPassFilter lowPass = new LowPassFilter(0.25f, 4);
    Dictionary<int, List<float>> rawSamples = new();
    Dictionary<int, DiscreteSignal> filteredSignalsDict = new();

    enum  Mode
    {
        Playback,      // Playback results generated by PyTorch
        RealInference, // Myo EMG data
        SimInference,  // Validation data
        DataCollection // Collect data for finetuning
    }
    
    Mode mode = Mode.DataCollection;
    
    
    // Data collection fields
    public HandVisual _sourceHandL;
    public HandVisual _sourceHandR;
    
    
    void Awake()
    {
        OVRPlugin.systemDisplayFrequency = 100.0f;
        Application.targetFrameRate = 100;

        BetterStreamingAssets.Initialize();

        switch (mode)
        {
            case Mode.RealInference:
                // Subscribe to Oculus hand update event
                // OVRHand.HandStateUpdatedEvent.AddListener(OnHandStateUpdated);
                break;
            case Mode.SimInference:
                // Load RawEMG-2023-03-22-13.15.34-predicted.csv from streamingAssets
                // string csv_path = Path.Combine(Application.streamingAssetsPath, "RawEMG-2023-03-22-13.15.34-predicted.csv");
                // string csv_path = Path.Combine(Application.streamingAssetsPath, "hu_2022_sample.csv");
                string[] csv_lines = BetterStreamingAssets.ReadAllLines("tcn_samples.csv");
                foreach (string line in csv_lines)
                {
                    string[] values = line.Split(',');
                    float[] emgReading = new float[MyoClassification.INPUT_DIM];
                    // Read EMG data
                    for(int i = 0; i < MyoClassification.INPUT_DIM; i++)
                    {
                        emgReading[i] = float.Parse(values[i]);
                    }
                    csvEMGData.Add(emgReading);
                }
                Debug.Log("Loaded " + csvEMGData.Count + " EMG samples.");
                break;
            case Mode.DataCollection:
                _sourceHandL.InjectOptionalUpdateRootPose(true);
                _sourceHandR.InjectOptionalUpdateRootPose(true);
                break;
        }
    }

    private void Start()
    {
        _myoClassification = GetComponent<MyoClassification>();
    }

    private bool prevSame(int[] newEMG)
    {
        for(int i = 0; i < MyoClassification.INPUT_DIM; i++)
        {
            if(newEMG[i] != prevEMG[i])
                return false;
        }
        return true;
    }


    bool counterSwitch = false;
    int[] prevEMG = new int[MyoClassification.INPUT_DIM];
    private void Update()
    {
        KeyListener();
        
        if(!inferenceActive)
            return;

        switch (mode)
        {
            case Mode.RealInference:
                var data = ThalmicMyo.emg;
                // Check data for null
                if(data == null || data.Length < 8)
                    return;
                
                // Check if data is the same as previous
                if(prevSame(data))
                    return;
                
                // Debug.Log(data[0]);
                EnqueueEMGReading(ThalmicMyo.emg);
                if (myoDataQueue.Count == MyoClassification.SEQ_LEN)
                {
                    QueueToTensors();
                    if (counterSwitch)
                        RunInference();
                    counterSwitch = !counterSwitch;
                }
                prevEMG = data;
                break;
            
            case Mode.SimInference:
                var csvData = csvEMGData[csvDataCounter];
                
                EnqueueEMGReading(csvData);
                QueueToTensors();
                if(myoDataQueue.Count == MyoClassification.SEQ_LEN)
                    RunInference();

                if (counterSwitch)
                    csvDataCounter += 1;
                counterSwitch = !counterSwitch;
                
                if (csvDataCounter >= csvEMGData.Count)
                {
                    csvDataCounter = 0;
                    Debug.Log("Loop");
                }
                break;
            
            case Mode.Playback:
                // Load data from csv list
                csvDataCounter += 1;
                // Loop
                if (csvDataCounter >= csvEMGData.Count)
                {
                    csvDataCounter = 0;
                    Debug.Log("Loop");
                }
                break;
            case Mode.DataCollection:
                var emgData = ThalmicMyo.emg;
                // Check data for null
                if(emgData == null || emgData.Length < 8)
                    return;
                
                
                
                break;
                
        }
    }

    private int warmupCounter = 0;
    float[] lastResultValues = new float[8];
    public void RunInference()
    {
        _myoClassification.Invoke();
        var resultValues = _myoClassification.resultValues;
        
        // if (rawSamples.Count > 0 && Math.Abs(rawSamples[0][^1] - resultValues[0]) < 0.01f)
            // return;
        
        // while(MyoClassification.outputQ.Count > 0)
        // {
        //     bool gotResult = MyoClassification.outputQ.TryDequeue(out var outputTensor);
        //     if (!gotResult)
        //         continue;
        //     
        //     for (int i = 0; i < MyoClassification.OUTPUT_DIM; i++)
        //     {
        //         // Get last "output_dim" values of outputArray
        //         var value = outputTensor[0, MyoClassification.TGT_LEN - 1, i];
        //         resultValues[i] = value;
        //     }
        //     
        //     // Add to discrete signal
        //     if (rawSamples.Count == 0)
        //     {
        //         for (int i = 0; i < 8; i++)
        //         {
        //             rawSamples.Add(i, new List<float>());
        //             filteredSignalsDict.Add(i, new DiscreteSignal(100, new float[MyoClassification.TGT_LEN]));
        //         }
        //     }
        //
        //     // Add results to raw samples
        //     for (int i = 0; i < 8; i++)
        //     {
        //         rawSamples[i].Add(resultValues[i]);
        //         if (rawSamples[i].Count > MyoClassification.TGT_LEN)
        //             rawSamples[i].RemoveAt(0);
        //     }
        //     warmupCounter += 1;
        //     if (warmupCounter < MyoClassification.TGT_LEN)
        //         return;
        //
        //     // Convert raw samples to discrete signal
        //     foreach (var key in rawSamples.Keys)
        //     {
        //         for (int i = 0; i < MyoClassification.TGT_LEN; i++)
        //         {
        //             filteredSignalsDict[key].Samples[i] = rawSamples[key][i];
        //         }
        //         var filteredSignal = lowPass.ApplyTo(filteredSignalsDict[key]);
        //         filteredSignalsDict[key] = filteredSignal;
        //     }
        //
        //     // Get last 8 samples from filteredSignals
        //     for (int i = 0; i < 8; i++)
        //     {
        //         resultValues[i] = filteredSignalsDict[i].Samples[^1];
        //     }
        //
        //     _handModifierR.UpdateJointData(resultValues);
        // }
        
        
        _handModifierR.UpdateJointData(resultValues);
        
    }

    private void EnqueueEMGReading(int[] emgReading)
    {
        // Convert emgReading to float[]
        float[] emgReadingFloat = new float[MyoClassification.INPUT_DIM];
        for (int i = 0; i < MyoClassification.INPUT_DIM; i++)
        {
            emgReadingFloat[i] = emgReading[i];
        }
        myoDataQueue.Add(emgReadingFloat);

        // If we have reached SEQ_LEN readings, remove the oldest one, but not SOS token
        if (myoDataQueue.Count > MyoClassification.SEQ_LEN)
            myoDataQueue.RemoveAt(0);
    }
    
    private void EnqueueEMGReading(float[] emgReading)
    {
        // Convert emgReading to float[]
        myoDataQueue.Add(emgReading);
        // If we have reached SEQ_LEN readings, remove the oldest one, but not SOS token
        if (myoDataQueue.Count > MyoClassification.SEQ_LEN)
            myoDataQueue.RemoveAt(0);
    }
    
    private void QueueToTensors()
    {
        // Convert input queue to tensor
        int i = 0;
        foreach (var reading in myoDataQueue)
        {
            for (int j = 0; j < MyoClassification.INPUT_DIM; j++)
            {
                emgTensor[0, i, j] = reading[j];
            }
            i++;
        }
    }
    
    private void OnHandStateUpdated(OVRPlugin.Quatf[] rotations)
    {
        float[] angleReading = new float[MyoClassification.OUTPUT_DIM];
        var counter = 0;
        for (int i = 0; i < 30; i++)
        {
            if (i is
                6 or 7 or    // Index
                9 or 10 or   // Middle
                12 or 13 or  // Ring
                16 or 17     // Pinky
               )
            {
                var quat = qovr2q(rotations[i]);
                var angle = quat.eulerAngles.z;
                if(angle > 180)
                    angle = -360 + angle;
                angleReading[counter] = angle;
                counter++;
            }
        }
    }
    
    
    private Quaternion qovr2q(OVRPlugin.Quatf q)
    {
        var result = new Quaternion();
        result.x = q.x;
        result.y = q.y;
        result.z = q.z;
        result.w = q.w;
        return result;
    }
    
    private void KeyListener()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            Debug.Log("Inference " + (inferenceActive ? "deactivated" : "activated") + ".");
            inferenceActive = !inferenceActive;
        }
    }
}
