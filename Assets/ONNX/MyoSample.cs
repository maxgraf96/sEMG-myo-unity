using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML.OnnxRuntime.Tensors;
using UnityEngine;
using NWaves.Filters.Butterworth;
using NWaves.Signals;
using Oculus.Interaction;
using UnityEngine.Serialization;
using LowPassFilter = NWaves.Filters.Butterworth.LowPassFilter;

public class MyoSample : MonoBehaviour
{
    private MyoClassification _myoClassification;
    // Visualisation hand that doesn't follow Oculus tracking, just for demo purposes of produced joint angle data
    [FormerlySerializedAs("_handModifierR")] public OVRsEMGHandModifier _visHandModifierR;

    // When hands are synced, we activate this hand modifier, which is attached to the virtual hand that actually
    // follows Oculus tracking, overwriting just the joint angles we produce
    public OVRsEMGHandModifier _realHandModifierR;

    // Raw EMG data
    List<float[]> myoDataQueue = new(MyoClassification.SEQ_LEN);
    // Placeholder for bandpassed EMG data
    List<float[]> myoDataQueueFiltered = new(MyoClassification.SEQ_LEN);
    // Input tensor for ONNX model
    public static float[,,] inputTensor = new float[1, MyoClassification.INPUT_TENSOR_LEN, MyoClassification.INPUT_DIM];
    
    private bool inferenceActive = true;
    
    private OVRPlugin.Quatf[] _handRotationsR;

    List<float[]> csvEMGData = new();
    List<float[]> csvAngleData = new();
    private int csvEMGDataCounter = 0;
    private int csvAngleDataCounter = 0;


    private LowPassFilter lowPassFilterOutputAngles = new LowPassFilter(0.2f, 6);
    Dictionary<int, List<float>> rawOutputAngles = new();
    Dictionary<int, DiscreteSignal> filteredOutputAngles = new();

    enum  Mode
    {
        Playback,      // Playback results generated by PyTorch
        RealInference, // Myo EMG data
        SimInference,  // Validation data
        DataCollection // Collect data for finetuning
    }
    
    // Mode mode = Mode.DataCollection;
    // Mode mode = Mode.RealInference;
    Mode mode = Mode.SimInference;
    
    
    // Data collection fields
    public HandVisual _sourceHandL;
    public HandVisual _sourceHandR;
    
    static int fs = 100;
    float lowCut = 20.0f / fs;
    float highCut = 25.0f / fs;
    int filterOrder = 4;
    private BandPassFilter butter;

    // For simulated inference - whether we are visualising the "true" values (coming from python -> ONNX pipeline)
    // or the values produced by the Unity -> ONNX pipeline
    private bool isSiminferenceGT = false;
    // private int numGTPredictions = 635;
    private int numGTPredictions = 12065;
    
    
    void Awake()
    {
        // Set target FPS
        OVRPlugin.systemDisplayFrequency = 120.0f;
        Application.targetFrameRate = 120;

        // Set up BetterStreamingAssets
        BetterStreamingAssets.Initialize();
        
        // Set up band pass filter for raw EMG filtering
        butter = new BandPassFilter(lowCut, highCut, filterOrder);
        for(int channel = 0; channel < MyoClassification.SEQ_LEN; channel++)
        {
            myoDataQueueFiltered.Add(new float[MyoClassification.INPUT_DIM]);
        }
        
        // Subscribe to button events
        ButtonControls.HandSyncButtonToggledEvent.AddListener(OnHandSyncButtonToggled);

        switch (mode)
        {
            case Mode.RealInference:
                // Subscribe to Oculus hand update event
                OVRHand.HandStateUpdatedEvent.AddListener(OnHandStateUpdated);
                break;
            case Mode.SimInference:
                // string[] csv_lines = BetterStreamingAssets.ReadAllLines("finetuned_onnx_test.csv");
                string[] csv_lines = BetterStreamingAssets.ReadAllLines("finetuned_onnx_train.csv");
                int counter = 0;
                foreach (string line in csv_lines)
                {
                    string[] values = line.Split(',');
                    float[] reading = new float[MyoClassification.INPUT_DIM];
                    // Read data - if counter is less than numPredictions, we are reading the EMG data
                    // Otherwise, we are reading the angle data
                    for(int i = 0; i < MyoClassification.INPUT_DIM; i++)
                    {
                        reading[i] = float.Parse(values[i]);
                    }

                    if (counter < numGTPredictions * MyoClassification.SEQ_LEN)
                    {
                        csvEMGData.Add(reading);
                    }
                    else
                    {
                        csvAngleData.Add(reading);
                    }
                    
                    counter++;
                }
                Debug.Log("Loaded " + csvEMGData.Count + " EMG samples.");
                break;
            case Mode.DataCollection:
                // Subscribe to hand updated events from Oculus hand data
                OVRHand.HandStateUpdatedEvent.AddListener(OnHandStateUpdated);
                // Enable pose updates to the rendered virtual hands move correctly
                _sourceHandL.InjectOptionalUpdateRootPose(true);
                _sourceHandR.InjectOptionalUpdateRootPose(true);
                // Subscribe to our custom recording toggle event
                ButtonControls.RecordingButtonToggledEvent.AddListener(OnRecordingButtonToggled);
                break;
            case Mode.Playback:
                string[] csv_l = BetterStreamingAssets.ReadAllLines(".csv");
                break;
        }
    }

    private void OnHandSyncButtonToggled(bool shouldHandsSync)
    {
        _realHandModifierR.enabled = shouldHandsSync;
    }

    private bool isRecordingData;
    private void OnRecordingButtonToggled(bool isRecording)
    {
        isRecordingData = isRecording;
        if(isRecording)
            GetComponent<Finetuning>().StartRecording();
        else
            GetComponent<Finetuning>().StopRecording();
        
    }

    private void Start()
    {
        _myoClassification = GetComponent<MyoClassification>();
    }

    private void Update()
    {
        KeyListener();
        
        if(!inferenceActive)
            return;

        switch (mode)
        {
            case Mode.RealInference:
                var data = ThalmicMyo.emg;
                // Check data for null
                if(data == null || data.Length < 8)
                    return;

                EnqueueEMGReading(ThalmicMyo.emg);
                if (myoDataQueue.Count == MyoClassification.SEQ_LEN)
                {
                    QueueToTensors();
                    RunInference();
                }
                break;
            
            case Mode.SimInference:
                if (isSiminferenceGT)
                {
                    // Take angle readings from csv
                    var csvData = csvAngleData[csvAngleDataCounter];
                    
                    var gtOutputTensor = new DenseTensor<float>(new[] { 1, MyoClassification.TGT_LEN, MyoClassification.OUTPUT_DIM });
                    for (int i = 0; i < MyoClassification.TGT_LEN; i++)
                    {
                        for (int j = 0; j < MyoClassification.OUTPUT_DIM; j++)
                        {
                            gtOutputTensor[0, i, j] = csvData[j];
                        }
                    }
                    
                    MyoClassification.outputQ.Enqueue(gtOutputTensor);
                    HandleOutputQueue();

                    csvAngleDataCounter++;
                    if (csvAngleDataCounter >= csvAngleData.Count)
                    {
                        csvAngleDataCounter = 0;
                        Debug.Log("Loop");
                    }
                }
                else
                {
                    var csvData = csvEMGData[csvEMGDataCounter];
                
                    EnqueueEMGReading(csvData);
                    if (myoDataQueue.Count == MyoClassification.SEQ_LEN)
                    {
                        QueueToTensors();
                        RunInference();
                    }

                    csvEMGDataCounter += 1;
                
                    if (csvEMGDataCounter >= csvEMGData.Count)
                    {
                        csvEMGDataCounter = 0;
                        Debug.Log("Loop");
                    }
                }
                
                break;
            
            case Mode.Playback:
                // Load data from csv list
                csvEMGDataCounter += 1;
                // Loop
                if (csvEMGDataCounter >= csvEMGData.Count)
                {
                    csvEMGDataCounter = 0;
                    Debug.Log("Loop");
                }
                break;
            case Mode.DataCollection:
                if(!isRecordingData)
                    return;
                
                var emgData = ThalmicMyo.emg;
                // Check data for null
                if(emgData == null || emgData.Length < 8)
                    return;
                
                GetComponent<Finetuning>().AddReadings(emgData, lastOVRReading);
                
                break;
                
        }
    }

    private int warmupCounter = 0;
    public void RunInference()
    {
        _myoClassification.Invoke();
        HandleOutputQueue();
    }

    private void HandleOutputQueue()
    {
        float[] resultValues = new float[MyoClassification.OUTPUT_DIM];
        while(MyoClassification.outputQ.Count > 0)
        {
            bool gotResult = MyoClassification.outputQ.TryDequeue(out var outputTensor);
            if (!gotResult)
                continue;
            
            for (int i = 0; i < MyoClassification.OUTPUT_DIM; i++)
            {
                // Get last "output_dim" values of outputArray
                var value = outputTensor[0, MyoClassification.TGT_LEN - 1, i];
                resultValues[i] = value;
            }
            
            // Add to discrete signal
            if (rawOutputAngles.Count == 0)
            {
                for (int i = 0; i < 8; i++)
                {
                    rawOutputAngles.Add(i, new List<float>());
                    filteredOutputAngles.Add(i, new DiscreteSignal(100, new float[MyoClassification.SEQ_LEN]));
                }
            }
            
            // Add results to raw samples
            for (int i = 0; i < 8; i++)
            {
                rawOutputAngles[i].Add(resultValues[i]);
                if (rawOutputAngles[i].Count > MyoClassification.SEQ_LEN)
                    rawOutputAngles[i].RemoveAt(0);
            }
            warmupCounter += 1;
            if (warmupCounter < MyoClassification.SEQ_LEN)
                return;
            
            // Convert raw samples to discrete signal
            foreach (var jointIndex in rawOutputAngles.Keys)
            {
                for (int i = 0; i < MyoClassification.SEQ_LEN; i++)
                {
                    filteredOutputAngles[jointIndex].Samples[i] = rawOutputAngles[jointIndex][i];
                }
                var filteredSignal = lowPassFilterOutputAngles.ApplyTo(filteredOutputAngles[jointIndex]);
                filteredOutputAngles[jointIndex] = filteredSignal;
            }
            
            // Get last 8 samples from filteredSignals
            for (int i = 0; i < 8; i++)
            {
                resultValues[i] = filteredOutputAngles[i].Samples[^1];
            }
        
            _visHandModifierR.UpdateJointData(resultValues);
            
            if(_realHandModifierR.enabled)
                _realHandModifierR.UpdateJointData(resultValues);
        }
    }

    private void EnqueueEMGReading(int[] emgReading)
    {
        // Convert emgReading to float[]
        float[] emgReadingFloat = new float[MyoClassification.INPUT_DIM];
        for (int i = 0; i < MyoClassification.INPUT_DIM; i++)
        {
            emgReadingFloat[i] = emgReading[i];
        }
        myoDataQueue.Add(emgReadingFloat);

        // If we have reached SEQ_LEN readings, remove the oldest one, but not SOS token
        if (myoDataQueue.Count > MyoClassification.SEQ_LEN)
            myoDataQueue.RemoveAt(0);
    }
    
    private void EnqueueEMGReading(float[] emgReading)
    {
        // Convert emgReading to float[]
        myoDataQueue.Add(emgReading);
        // If we have reached SEQ_LEN readings, remove the oldest one
        if (myoDataQueue.Count > MyoClassification.SEQ_LEN)
            myoDataQueue.RemoveAt(0);
    }
    
    private void QueueToTensors()
    {
        FilterEMGQueue();
        // Extract features
        ExtractFeatures();
        for(int feature = 0; feature < MyoClassification.FEATURE_LEN; feature++)
        {
            for(int j = 0; j < MyoClassification.INPUT_DIM; j++)
            {
                if (feature == 0)
                    inputTensor[0, feature, j] = _features.mav[j];
                else if (feature == 1)
                    inputTensor[0, feature, j] = _features.rms[j];
                else if (feature == 2)
                    inputTensor[0, feature, j] = _features.variances[j];
                else if (feature == 3)
                    inputTensor[0, feature, j] = _features.mdf[j];
                else if (feature == 4)
                    inputTensor[0, feature, j] = _features.mnf[j];
                else if (feature == 5)
                    inputTensor[0, feature, j] = _features.pf[j];
            }
                
        }
        
        // Add filtered sEMG samples to tensor
        int i = 0;
        foreach (var reading in myoDataQueueFiltered)
        {
            for (int j = 0; j < MyoClassification.INPUT_DIM; j++)
            {
                inputTensor[0, MyoClassification.FEATURE_LEN + i, j] = reading[j];
            }
            i++;
        }
        
        // Add last angle reading to tensor
        for (int j = 0; j < MyoClassification.INPUT_DIM; j++)
        {
            inputTensor[0, MyoClassification.INPUT_TENSOR_LEN - 1, j] = lastOVRReading[j];
        }
    }

    struct Features {
        public float[] mav;
        public float[] rms;
        public float[] variances;
        public float[] mdf;
        public float[] mnf;
        public float[] pf;
    }

    private Features _features;
    private void ExtractFeatures()
    {
        // Channel-wise, get mean absolute values, RMS and variance
        var mav = new float[MyoClassification.INPUT_DIM];
        var rms = new float[MyoClassification.INPUT_DIM];
        var variances = new float[MyoClassification.INPUT_DIM];
        var mdf = new float[MyoClassification.INPUT_DIM];
        var mnf = new float[MyoClassification.INPUT_DIM];
        var pf = new float[MyoClassification.INPUT_DIM];
        for (int channel = 0; channel < MyoClassification.INPUT_DIM; channel++)
        {
            var channelData = myoDataQueueFiltered.Select(x => x[channel]).ToArray();

            // Time domain features
            mav[channel] = channelData.Average(x => Math.Abs(x));
            rms[channel] = (float) Math.Sqrt(channelData.Average(x => x * x));
            // Variance
            variances[channel] = (float) channelData.Select(x => Math.Pow(x - channelData.Average(), 2)).Sum() / (channelData.Length - 1);
            
            // Frequency domain features
            double[] psd = FeatureExtractor.PowerSpectralDensity(channelData);
            mdf[channel] = FeatureExtractor.MedianFrequency(psd);
            mnf[channel] = FeatureExtractor.MeanFrequency(psd);
            pf[channel] = FeatureExtractor.PeakFrequency(psd);
        }
        _features.mav = mav;
        _features.rms = rms;
        _features.variances = variances;
        _features.mdf = mdf;
        _features.mnf = mnf;
        _features.pf = pf;
    }

    /// <summary>
    /// Take all the samples in the MyoDataQueue and apply a band pass filter to them
    /// </summary>
    private void FilterEMGQueue()
    {
        
        for (int channel = 0; channel < MyoClassification.INPUT_DIM; channel++)
        {
            DiscreteSignal signal = new DiscreteSignal(fs, myoDataQueue.Select(x => x[channel]).ToArray());
            var filChannelSig = butter.ApplyTo(signal);
            for (int i = 0; i < MyoClassification.SEQ_LEN; i++)
            {
                // TODO This might be bad
                myoDataQueueFiltered[i][channel] = filChannelSig.Samples[i];
            }
        }
    }

    private float[] lastOVRReading = new float[MyoClassification.OUTPUT_DIM];
    private void OnHandStateUpdated(OVRPlugin.Quatf[] rotations, OVRHand.Hand hand)
    {
        if(hand != OVRHand.Hand.HandRight)
            return;
        
        float[] angleReading = new float[MyoClassification.OUTPUT_DIM];
        var counter = 0;
        for (int i = 0; i < 30; i++)
        {
            if (i is
                6 or 7 or    // Index
                9 or 10 or   // Middle
                12 or 13 or  // Ring
                16 or 17     // Pinky
               )
            {
                var quat = qovr2q(rotations[i]);
                var angle = quat.eulerAngles.z;
                if(angle > 180)
                    angle = -360 + angle;
                angleReading[counter] = angle;
                counter++;
            }
        }
        lastOVRReading = angleReading;
    }
    
    
    private Quaternion qovr2q(OVRPlugin.Quatf q)
    {
        var result = new Quaternion();
        result.x = q.x;
        result.y = q.y;
        result.z = q.z;
        result.w = q.w;
        return result;
    }
    
    private void KeyListener()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            Debug.Log("Inference " + (inferenceActive ? "deactivated" : "activated") + ".");
            inferenceActive = !inferenceActive;
        }
        else if (Input.GetKeyDown(KeyCode.S))
        {
            isSiminferenceGT = !isSiminferenceGT;
            if(isSiminferenceGT)
                csvAngleDataCounter = 0;
            else 
                csvEMGDataCounter = 0;
            string newGTMode = isSiminferenceGT ? "Python ONNX" : "Unity ONNX";
            Debug.Log("Switched to " + newGTMode + ".");
        }
    }
}
