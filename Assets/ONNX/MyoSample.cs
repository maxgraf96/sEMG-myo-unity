using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class MyoSample : MonoBehaviour
{
    private MyoClassification _myoClassification;
    public OVRsEMGHandModifier _handModifierR;

    List<float[]> myoDataQueue = new(MyoClassificationTF.SEQ_LEN);
    float[,,] emgTensor = new float[1, MyoClassificationTF.SEQ_LEN, MyoClassificationTF.INPUT_DIM];
    
    private bool inferenceActive = true;
    
    private OVRPlugin.Quatf[] _handRotationsR;

    List<float[]> csvEMGData = new();
    List<float[]> csvAngleData = new();
    private int csvDataCounter = 0;

    enum  Mode
    {
        Playback,      // Playback results generated by PyTorch
        RealInference, // Myo EMG data
        SimInference,  // Validation data
    }
    
    Mode mode = Mode.SimInference;
    
    void Awake()
    {
        OVRPlugin.systemDisplayFrequency = 100.0f;
        Application.targetFrameRate = 100;

        BetterStreamingAssets.Initialize();

        switch (mode)
        {
            case Mode.RealInference:
                // Subscribe to Oculus hand update event
                OVRHand.HandStateUpdatedEvent.AddListener(OnHandStateUpdated);
                break;
            case Mode.SimInference:
                // Load RawEMG-2023-03-22-13.15.34-predicted.csv from streamingAssets
                // string csv_path = Path.Combine(Application.streamingAssetsPath, "RawEMG-2023-03-22-13.15.34-predicted.csv");
                // string csv_path = Path.Combine(Application.streamingAssetsPath, "hu_2022_sample.csv");
                string[] csv_lines = BetterStreamingAssets.ReadAllLines("tcn_samples.csv");
                foreach (string line in csv_lines)
                {
                    string[] values = line.Split(',');
                    float[] emgReading = new float[MyoClassificationTF.INPUT_DIM];
                    // Read EMG data
                    for(int i = 0; i < MyoClassificationTF.INPUT_DIM; i++)
                    {
                        emgReading[i] = float.Parse(values[i]);
                    }
                    csvEMGData.Add(emgReading);
                }
                Debug.Log("Loaded " + csvEMGData.Count + " EMG samples.");
                break;
        }
    }

    private void Start()
    {
        _myoClassification = GetComponent<MyoClassification>();
    }


    private void Update()
    {
        KeyListener();
        
        if(!inferenceActive)
            return;

        switch (mode)
        {
            case Mode.RealInference:
                var data = ThalmicMyo.emg;
                // Check data for null
                if(data == null || data.Length < 8)
                    return;
            
                EnqueueEMGReading(ThalmicMyo.emg);
                if (myoDataQueue.Count == MyoClassificationTF.SEQ_LEN)
                {
                    QueueToTensors();
                    RunInference(emgTensor);
                }
                break;
            
            case Mode.SimInference:
                var csvData = csvEMGData[csvDataCounter];
                
                EnqueueEMGReading(csvData);
                QueueToTensors();
                if(myoDataQueue.Count == MyoClassificationTF.SEQ_LEN)
                    RunInference(emgTensor);

                csvDataCounter++;
                if (csvDataCounter >= csvEMGData.Count)
                {
                    csvDataCounter = 0;
                    Debug.Log("Loop");
                }
                break;
            
            case Mode.Playback:
                // Load data from csv list
                csvDataCounter += 1;
                // Loop
                if (csvDataCounter >= csvEMGData.Count)
                {
                    csvDataCounter = 0;
                    Debug.Log("Loop");
                }
                break;
        }
    }

    public void RunInference(float[,,] emgTensor)
    {
        _myoClassification.Invoke(emgTensor);
        var resultValues = _myoClassification.resultValues;
        
        // Debug.Log(resultValues[0] + " " + resultValues[1] + " " + resultValues[2] + " " + resultValues[3] + " " + resultValues[4] + " " + resultValues[5] + " " + resultValues[6] + " " + resultValues[7]);
        
        _handModifierR.UpdateJointData(resultValues);
    }

    private void EnqueueEMGReading(int[] emgReading)
    {
        // Convert emgReading to float[]
        float[] emgReadingFloat = new float[MyoClassificationTF.INPUT_DIM];
        for (int i = 0; i < MyoClassificationTF.INPUT_DIM; i++)
        {
            emgReadingFloat[i] = emgReading[i];
        }
        myoDataQueue.Add(emgReadingFloat);

        // If we have reached SEQ_LEN readings, remove the oldest one, but not SOS token
        if (myoDataQueue.Count > MyoClassificationTF.SEQ_LEN)
            // myoDataQueue.RemoveAt(1);
            myoDataQueue.RemoveAt(0);
    }
    
    private void EnqueueEMGReading(float[] emgReading)
    {
        // Convert emgReading to float[]
        myoDataQueue.Add(emgReading);
        // If we have reached SEQ_LEN readings, remove the oldest one, but not SOS token
        if (myoDataQueue.Count > MyoClassificationTF.SEQ_LEN)
            myoDataQueue.RemoveAt(0);
    }
    
    private void QueueToTensors()
    {
        // Convert input queue to tensor
        int i = 0;
        foreach (var reading in myoDataQueue)
        {
            for (int j = 0; j < MyoClassificationTF.INPUT_DIM; j++)
            {
                emgTensor[0, i, j] = reading[j];
            }
            i++;
        }
    }
    
    private void OnHandStateUpdated(OVRPlugin.Quatf[] rotations)
    {
        // float[] angleReading = new float[MyoClassification.OUTPUT_DIM];
        // var counter = 0;
        // for (int i = 0; i < 30; i++)
        // {
        //     if (i is
        //         6 or 7 or    // Index
        //         9 or 10 or   // Middle
        //         12 or 13 or  // Ring
        //         16 or 17     // Pinky
        //        )
        //     {
        //         var quat = qovr2q(rotations[i]);
        //         var angle = quat.eulerAngles.z;
        //         if(angle > 180)
        //             angle = -360 + angle;
        //         angleReading[counter] = angle;
        //         counter++;
        //     }
        // }
        // // Buggy 0-value angle readings sometimes, only pass in if not all 0
        // if (angleReading[0] != 0 && angleReading[1] != 0 && angleReading[2] != 0 && angleReading[3] != 0 &&
        //     angleReading[4] != 0 && angleReading[5] != 0 && angleReading[6] != 0 && angleReading[7] != 0)
        // {
        //     EnqueueTgtReading(angleReading);
        //     Debug.Log("Oculus finger angles:" + angleReading[0] + " " + angleReading[1] + " " + angleReading[2] + " " + angleReading[3] + " " + angleReading[4] + " " + angleReading[5] + " " + angleReading[6] + " " + angleReading[7]);   
        // }
    }
    
    
    private Quaternion qovr2q(OVRPlugin.Quatf q)
    {
        var result = new Quaternion();
        result.x = q.x;
        result.y = q.y;
        result.z = q.z;
        result.w = q.w;
        return result;
    }
    
    private void KeyListener()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            Debug.Log("Inference " + (inferenceActive ? "deactivated" : "activated") + ".");
            inferenceActive = !inferenceActive;
        }
    }
}
